1. CRC:					20 Bytes
2. Header start:		24 Bytes
3. Header information:	?? Bytes
4. Levels:				ARRAY LENGTH followed by STRINGs
5. Keyframe:			ARRAY LENGTH followed by STRUCT(Time, Frame, File position)
6. Network Stream:		ARRAY LENGTH followed by BYTES
	- Current Time FLOAT
	- Delta Time FLOAT
	- Actors that stoppped replicating:
		+ Signal destroyed actor - 1 BIT
		+ Actor's network channel ID - COMPRESSED INTEGER
		+ Signal channel closing - 1 BIT
	- Actors that started replicating:
		+ Signal spawned actor - 1 BIT
		+ Actor's network channel ID - COMPRESSED INTEGER
		+ Signal channel open - 1 BIT
		+ Signal new actor - 1 BIT
		+ Data on how to reference actor:
			> Static actor:
				| INTEGER ID from Objects Table
			> Dynamic actor:
				| INTEGER ID for 'Archetype'
				| (Optional) Initial location {VECTOR}
				| (Optional*) Rotation(Pitch, Yaw, Roll - 3 BYTES total)
	- Actors replicating:
		+ Signal replicating actor - 1 BIT
		+ Actor's network channel ID - COMPRESSED INTEGER
		+ Signal channel is open - 1 BIT
		+ Signal not a new actor - 1 BIT
		+ Stream of Properties and Values:
			> Signal new Property - 1 BIT
			> Property ID - COMPRESSED PROPERTY ID (Max value pulled from Class Net Cache)
			> 
7. !Debug Logs:			ARRAY LENGTH followed by STRINGs
8. Tick Marks:			ARRAY LENGTH followed by STRUCT(Type, Frame)
9. Replicated packages: ??
10. Object table:		??
11. Name Table:			??
12. Class Index Map:	??
13. CNC Map:			??


# NOTE 1 #
For each frame, first there are 2 floats for Time and DeltaTime.
Then a single bit with a value of 1 to say we have actors that were destroyed,
so it is expected that the first frame of the replay would have a 0 for that bit
since no actors have been destroyed yet. If an actor has been destroyed it then
puts the 10 bits for the channel ID, no padding (I think). If no actors were destroyed
it just moves on to the next phase (actors that were spawned).

The optional location and rotation are in the following bits, no property identifiers.
It looks like actors always write their compressed vector location. The way we know if
it needs initial rotation is by checking properties on the class at runtime (Actor.bNetInitialRotation),
which is part of the game, not included with the replay.

Vectors are compressed over the network, and the amount of bits they take depends on the vector.
The code used for serializing them is the same as in UE4's FVector_NetQuantize NetSerialize() function.


# NOTE 2 #
https://gitlab.com/taylorfausak/octane/blob/master/README.md
